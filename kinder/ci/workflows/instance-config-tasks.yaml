# AUTOGENERATED by https://git.k8s.io/kubeadm/kinder/ci/tools/update-workflows
# IMPORTANT! this workflow is imported by instance-config-* workflows.
version: 1
summary: |
  This workflow implements a sequence of tasks to test that kubeadm
  works properly in scenarios using kubelet instance configuration.
vars:
  # vars defines default values for variable used by tasks in this workflow;
  # those values might be overridden when importing this files.
  kubernetesVersion: latest
  upgradeVersion: latest
  controlPlaneNodes: 3
  workerNodes: 2
  baseImage: kindest/base:v20221102-76f15095 # has containerd
  image: kindest/node:test
  clusterName: kinder-instance-config
  kubeadmVerbosity: 6
tasks:
- name: pull-base-image
  description: |
    pulls kindest/base image with docker in docker and all the prerequisites necessary for running kind(er)
  cmd: docker
  args:
  - pull
  - "{{ .vars.baseImage }}"
- name: add-kubernetes-versions
  description: |
    creates a node-image-variant by adding a Kubernetes version
  cmd: kinder
  args:
  - build
  - node-image-variant
  - --base-image={{ .vars.baseImage }}
  - --image={{ .vars.image }}
  - --with-init-artifacts={{ .vars.kubernetesVersion }}
  - --with-upgrade-artifacts={{ .vars.upgradeVersion }}
  - --loglevel=debug
  timeout: 15m
- name: create-cluster
  description: |
    create a set of nodes ready for hosting the Kubernetes cluster
  cmd: kinder
  args:
  - create
  - cluster
  - --name={{ .vars.clusterName }}
  - --image={{ .vars.image }}
  - --control-plane-nodes={{ .vars.controlPlaneNodes }}
  - --worker-nodes={{ .vars.workerNodes }}
  - --loglevel=debug
  timeout: 5m
- name: init
  description: |
    Initializes the Kubernetes cluster with version "initVersion"
    by starting the boostrap control-plane nodes
  cmd: kinder
  args:
  - do
  - kubeadm-init
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  - --kubeadm-verbosity={{ .vars.kubeadmVerbosity }}
  - --kubeadm-feature-gate="NodeLocalCRISocket=false"
  - --copy-certs=auto
  timeout: 5m
- name: join
  description: |
    Join the other nodes to the Kubernetes cluster
  cmd: kinder
  args:
  - do
  - kubeadm-join
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  - --kubeadm-verbosity={{ .vars.kubeadmVerbosity }}
  - --copy-certs=auto
  timeout: 10m
- name: check-annotation
  description: |
    Check that the cri-socket annotation does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      docker exec {{ .vars.clusterName }}-control-plane-1 bash -c '
        nodes=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get nodes -o jsonpath="{.items[*].metadata.name}")

        for node in $nodes; do
          annotation=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get node "$node" -o jsonpath="{.metadata.annotations.kubeadm\.alpha\.kubernetes\.io\/cri-socket}")

          if [ -z "$annotation" ]; then
            echo "Annotation not found on node $node"
            exit 1
          else
            echo "Annotation found on node $node: $annotation"
          fi
        done
      ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }

      exit 0
  timeout: 5m
- name: check-config
  description: |
    Check if the kubelet instance configuration exists on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/instance-config.yaml" ]] && grep -q "containerRuntimeEndpoint:" /var/lib/kubelet/instance-config.yaml; then
            echo "File exists and contains 'containerRuntimeEndpoint:' field."
            exit 1
          else
            echo "File does not exist or does not contain 'containerRuntimeEndpoint:' field."
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: check-flag
  description: |
      Check that the container-runtime-endpoint flag does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/kubeadm-flags.env" ]] && grep -q "container-runtime-endpoint" /var/lib/kubelet/kubeadm-flags.env; then
            echo "File exists and contains 'container-runtime-endpoint' field."
          else
            echo "File does not contain 'container-runtime-endpoint' field."
            exit 1
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: upgrade
  description: |
    upgrades the cluster to Kubernetes "upgradeVersion"
  cmd: kinder
  args:
  - do
  - kubeadm-upgrade
  - --upgrade-version={{ .vars.upgradeVersion }}
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  - --kubeadm-verbosity={{ .vars.kubeadmVerbosity }}
  timeout: 15m
- name: wait-upgrade-complete
  description: |
    Wait for the cluster upgrade to complete
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      while true; do
        all_ready=true
        nodes=$(docker exec {{ .vars.clusterName }}-control-plane-1 bash -c 'KUBECONFIG=/etc/kubernetes/admin.conf kubectl get nodes -o jsonpath="{.items[*].metadata.name}"')

        for node in $nodes; do
          status=$(docker exec {{ .vars.clusterName }}-control-plane-1 bash -c "KUBECONFIG=/etc/kubernetes/admin.conf kubectl get node $node -o jsonpath='{.status.conditions[?(@.type==\"Ready\")].status}'")

          if [ "$status" != "True" ]; then
            echo "Node $node is not Ready (Status: $status)"
            all_ready=false
          else
            echo "Node $node is Ready"
          fi
        done

        if [ "$all_ready" = true ]; then
          echo "All nodes are Ready. Exiting."
          exit 0
        fi

        echo "Waiting 1 second before next check..."
        sleep 1
      done

      exit 0
  timeout: 2m
- name: check-config-after-upgrade
  description: |
    Check if the kubelet instance configuration exists on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/instance-config.yaml" ]] && grep -q "containerRuntimeEndpoint:" /var/lib/kubelet/instance-config.yaml; then
            echo "File exists and contains 'containerRuntimeEndpoint:' field."
            exit 1
          else
            echo "File does not exist or does not contain 'containerRuntimeEndpoint:' field."
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: check-flag-after-upgrade
  description: |
      Check that the container-runtime-endpoint flag does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/kubeadm-flags.env" ]] && grep -q "container-runtime-endpoint" /var/lib/kubelet/kubeadm-flags.env; then
            echo "File exists and contains 'container-runtime-endpoint' field."
          else
            echo "File does not contain 'container-runtime-endpoint' field."
            exit 1
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: check-annotation-after-upgrade
  description: |
    Check that the cri-socket annotation does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      docker exec {{ .vars.clusterName }}-control-plane-1 bash -c '
        nodes=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get nodes -o jsonpath="{.items[*].metadata.name}")

        for node in $nodes; do
          annotation=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get node "$node" -o jsonpath="{.metadata.annotations.kubeadm\.alpha\.kubernetes\.io\/cri-socket}")

          if [ -z "$annotation" ]; then
            echo "Annotation not found on node $node"
            exit 1
          else
            echo "Annotation found on node $node: $annotation"
          fi
        done
      ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }

      exit 0
  timeout: 5m

- name: enable-feature
  description: |
    enable the nodeLocalCRISocket Feature gate.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      docker exec {{ .vars.clusterName }}-control-plane-1 bash -c '
        KUBECONFIG=/etc/kubernetes/admin.conf kubectl get configmap kubeadm-config -n kube-system -o yaml > config.yaml
        sed '\''s/^\( *\)\(NodeLocalCRISocket:\) false$/\1\2 true/'\'' config.yaml > updated_config.yaml

        if grep -q "NodeLocalCRISocket: true" updated_config.yaml; then
          echo "Updating ConfigMap YAML Successful."
        else
          echo "Updating ConfigMap YAML failed."
          exit 1
        fi

        if KUBECONFIG=/etc/kubernetes/admin.conf kubectl apply -f updated_config.yaml; then
          echo "ConfigMap updated successfully."
        else
          echo "Failed to apply updated ConfigMap."
          exit 1
        fi

        rm config.yaml updated_config.yaml
      ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }

      exit 0
  timeout: 5m
- name: upgrade-again
  description: |
    upgrades the cluster to Kubernetes "upgradeVersion"
  cmd: kinder
  args:
  - do
  - kubeadm-upgrade
  - --upgrade-version={{ .vars.upgradeVersion }}
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  - --kubeadm-verbosity={{ .vars.kubeadmVerbosity }}
  timeout: 15m
- name: check-config-after-second-upgrade
  description: |
    Check if the kubelet instance configuration exists on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/instance-config.yaml" ]] && grep -q "containerRuntimeEndpoint:" /var/lib/kubelet/instance-config.yaml; then
            echo "File exists and contains 'containerRuntimeEndpoint:' field."
          else
            echo "File does not exist or does not contain 'containerRuntimeEndpoint:' field."
            exit 1
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: check-annotation-after-second-upgrade
  description: |
      Check that the cri-socket annotation does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      docker exec {{ .vars.clusterName }}-control-plane-1 bash -c '
        nodes=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get nodes -o jsonpath="{.items[*].metadata.name}")

        for node in $nodes; do
          annotation=$(KUBECONFIG=/etc/kubernetes/admin.conf kubectl get node "$node" -o jsonpath="{.metadata.annotations.kubeadm\.alpha\.kubernetes\.io\/cri-socket}")

          if [ -z "$annotation" ]; then
            echo "Annotation not found on node $node"
          else
            echo "Annotation found on node $node: $annotation"
            exit 1
          fi
        done
      ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      exit 0
  timeout: 5m
- name: check-flag-after-second-upgrade
  description: |
      Check that the container-runtime-endpoint flag does not exist on each node.
  cmd: /bin/bash
  args:
    - -c
    - |
      set -x

      for node in control-plane-{1..3} worker-{1..2}; do
        CMD="docker exec {{ .vars.clusterName }}-$node"

        ${CMD} bash -c '
          if [[ -f "/var/lib/kubelet/kubeadm-flags.env" ]] && grep -q "container-runtime-endpoint" /var/lib/kubelet/kubeadm-flags.env; then
            echo "File exists and contains 'container-runtime-endpoint' field."
            exit 1
          else
            echo "File does not contain 'container-runtime-endpoint' field."
          fi
        ' || {
        echo "Command failed for $node. Exiting.";
        exit 1;
        }
      done

      exit 0
  timeout: 5m
- name: cluster-info
  description: |
    Runs cluster-info
  cmd: kinder
  args:
  - do
  - cluster-info
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
- name: e2e-kubeadm
  description: |
    Runs kubeadm e2e tests
  cmd: kinder
  args:
  - test
  - e2e-kubeadm
  - --test-flags=--report-dir={{ .env.ARTIFACTS }} --report-prefix=e2e-kubeadm
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  timeout: 10m
- name: get-logs
  description: |
    Collects all the test logs
  cmd: kinder
  args:
  - export
  - logs
  - --loglevel=debug
  - --name={{ .vars.clusterName }}
  - "{{ .env.ARTIFACTS }}"
  force: true
  timeout: 5m
  # kind export log is know to be flaky, so we are temporary ignoring errors in order
  # to make the test pass in case everything else passed
  # see https://github.com/kubernetes-sigs/kind/issues/456
  ignoreError: true
- name: reset
  description: |
    Exec kubeadm reset
  cmd: kinder
  args:
  - do
  - kubeadm-reset
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  - --kubeadm-verbosity={{ .vars.kubeadmVerbosity }}
  force: true
- name: delete
  description: |
    Deletes the cluster
  cmd: kinder
  args:
  - delete
  - cluster
  - --name={{ .vars.clusterName }}
  - --loglevel=debug
  force: true
